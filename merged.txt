#pragma once
#include "quantum_gate.h"

#include <iostream>
#include <iomanip>

/// @file
/// @brief Small executor and convenience API for composing and running quantum gates.
///
/**
 * @details
 * `QuantumCircuit` is a lightweight compile-time helper to execute a sequence of
 * gate-like callables on an initialized state vector. The executor is templated
 * on the number of qubits and accepts any callable satisfying the `QuantumGateLike`
 * concept (i.e. callables that accept and return a `state_vector_t<N>`).
 */

template<index_t QBitCount>
class QuantumCircuit;

/// @brief Concept for types that behave like a gate: they are callable with a state vector.
/// @tparam G  Type to test.
///
/// The requirement checks one instantiation (with StateCount == 1) and uses that as a
/// proxy for gate-like behaviour. Implementers should ensure their operator() is
/// templated or overloaded appropriately for various `StateCount` values.
template<typename G>
concept QuantumGateLike =
    requires(G g)
{
    // Try invoking the gate with a sample 1-qubit state vector; the returned type
    // must be a state_vector_t<1>. This models the "callable that maps state->state".
    { g(state_vector_t<1>{}) } -> std::same_as<state_vector_t<1>>;
};

/// @brief Executor that schedules and runs a series of gate-like callables at compile-time (where possible).
/// @tparam QBitCount  Number of qubits in the circuit.
/// @tparam Gates      Variadic pack of gate-like callables accepted by the executor.
template<dimension_t QBitCount, QuantumGateLike... Gates>
class QuantumCircuitExecutor {

    /// @brief The internal global state vector (amplitudes for 2^QBitCount basis states).
    state_vector_t<ConstexprMath::pow2(QBitCount)> StateVector;

    /// @brief Construct executor and immediately execute provided gates.
    /// @param gates  Variadic list of gate-like callables to apply in order.
    constexpr QuantumCircuitExecutor(const Gates& ... gates)
    {
        // Initialize to the |0...0> computational basis state
        StateVector = {};
        StateVector[0] = cplx_t::fromReal(1.0);

        // Apply the provided gates in sequence
        executeCircuit(gates...);
    }

    friend class QuantumCircuit<QBitCount>;

public:
    /// @brief Recursively apply gates: head then recurse on tail.
    /// @tparam Gate  First gate type.
    /// @tparam Rest  Remaining gate types.
    /// @param gate   Gate callable to apply.
    /// @param rest   Remaining gate callables.
    template<typename Gate, typename... Rest>
    constexpr void executeCircuit(const Gate& gate, const Rest&... rest)
    {
        static_assert(QuantumGateLike<Gate>);

        // Apply the gate to the current state vector (gate returns a new vector)
        StateVector = gate(StateVector);

        // Recurse for the remaining gates
        executeCircuit(rest...);
    }

    /// @brief Base case for recursion: no gates left to apply.
    constexpr void executeCircuit() {}

    // ------------------------------------------------------------
    // Prints measurement probabilities of all computational states
    //
    // Example output:
    // |00> : 50.00 %
    // |11> : 50.00 %
    // ------------------------------------------------------------
    /// @brief Print the probability (in percent) of each computational basis state.
    /// @param os  Output stream (defaults to std::cout).
    void printProbabilities(std::ostream& os = std::cout) const
    {
        constexpr dimension_t StateCount = ConstexprMath::pow2(QBitCount);

        // Format numbers with two decimal places
        os << std::fixed << std::setprecision(2);

        for (dimension_t i = 0; i < StateCount; ++i)
        {
            const cplx_t& amp = StateVector[i];

            // Probability = |amplitude|^2 = re^2 + im^2
            const double probability =              
                static_cast<double>(amp.re * amp.re +
                    amp.im * amp.im);

            // Print basis state in binary ket notation: |0101>
            os << "|";

            for (dimension_t bit = 0; bit < QBitCount; ++bit)
            {
                // Mask selects bit from most-significant to least for human-readable order
                const dimension_t mask = dimension_t(1) << (QBitCount - 1 - bit);
                os << ((i & mask) ? '1' : '0');
            }

            os << "> : " << (probability * 100.0) << " %\n";
        }
    }
};

/// @brief Facade class to create executors bound to a fixed qubit count.
template<index_t QBitCount>
class QuantumCircuit
{
public:
    /// @brief Create an executor with the provided gate sequence.
    /// @tparam Gates  Gate-like callables to include in the circuit.
    /// @param gates   Instances of the gate-like callables (passed by reference-to-const).
    /// @return        A `QuantumCircuitExecutor` that has already executed the gates on an initialized state.
    template<QuantumGateLike... Gates>
    constexpr QuantumCircuitExecutor<QBitCount, Gates...> withGates(const Gates& ... gates) const
    {
        return QuantumCircuitExecutor<QBitCount, Gates...>(gates...);
    }
};
#pragma once
#include <concepts>


/// @file
/// @brief Constexpr-capable complex number type used throughout the project.
///
/**
 * @details
 * This header defines `ConstexprMath::Complex<T>`, a small constexpr-friendly
 * complex number type with a minimal set of operations required by the
 * simulator (construction, addition, subtraction, multiplication, in-place
 * accumulation and conjugation). All members and functions are `constexpr`
 * and `noexcept` where appropriate so they can be used in compile-time
 * contexts (constexpr initialization of gate matrices, etc.).
 */

namespace ConstexprMath
{
    /**
     * @brief Simple constexpr complex number for numeric computations.
     *
     * @tparam T  Floating-point type to store real and imaginary parts (e.g. double).
     *
     * The type exposes public data members `re` and `im` and lightweight
     * arithmetic operators implemented in a constexpr-friendly way. It is
     * intentionally minimal (no exceptions, no heap allocations).
     */
    template <std::floating_point T>
    struct Complex
    {
        /// @brief The real part of the complex number.
        T re = 0.0;
        /// @brief The imaginary part of the complex number.
        T im = 0.0;

        /// @brief Default constructor producing 0 + 0i.
        constexpr Complex() noexcept = default;

        /// @brief Construct a complex number from a real value (imaginary part = 0).
        /// @param r  Real part.
        constexpr Complex(T r) noexcept : re(r), im(0.0) {}

        /// @brief Construct a complex number from real and imaginary parts.
        /// @param r  Real part.
        /// @param i  Imaginary part.
        constexpr Complex(T r, T i) noexcept : re(r), im(i) {}

        /// @brief Return the additive identity 0 + 0i.
        /// @return Complex zero.
        static constexpr Complex zero() noexcept { return {}; }

        /// @brief Create a complex number from a real value (helper alias).
        /// @param r  Real part.
        /// @return Complex number r + 0i.
        static constexpr Complex fromReal(T r) noexcept { return { r, 0.0 }; }

        /// @brief Return the imaginary unit +i (0 + 1i).
        /// @return Complex representing i.
        static constexpr Complex plus_i() noexcept { return { 0.0, 1.0 }; }

        /// @brief Return the negative imaginary unit -i (0 - 1i).
        /// @return Complex representing -i.
        static constexpr Complex minus_i() noexcept { return { 0.0, -1.0 }; }

        /// @brief Component-wise addition.
        /// @param other  Addend.
        /// @return The sum (this + other).
        ///
        /// Example:
        /// @code
        /// Complex<double> a{1.0, 2.0};
        /// Complex<double> b{0.5, -1.0};
        /// auto c = a + b; // c == {1.5, 1.0}
        /// @endcode
        constexpr Complex operator+ (Complex other) const noexcept
        {
            // Add real and imaginary parts separately.
            return { re + other.re, im + other.im };
        }

        /// @brief Component-wise subtraction.
        /// @param other  Subtrahend.
        /// @return The difference (this - other).
        constexpr Complex operator- (Complex other) const noexcept
        {
            // Subtract real and imaginary parts separately.
            return { re - other.re, im - other.im };
        }

        /// @brief Complex multiplication following (a+bi)*(c+di) = (ac - bd) + (ad + bc)i.
        /// @param other  The multiplier.
        /// @return The product.
        constexpr Complex operator* (Complex other) const noexcept
        {
            // Compute using the standard formula to avoid temporaries where possible.
            return { re * other.re - im * other.im, re * other.im + im * other.re };
        }

        /// @brief In-place addition (accumulate another complex into this).
        /// @param other  Value to add.
        /// @return A reference to *this after addition (returned by value here for constexpr convenience).
        constexpr Complex operator+= (Complex other) noexcept
        {
            // Mutate both components; returning *this by value is acceptable for constexpr use.
            re += other.re;
            im += other.im;
            return *this;
        }
    };
}#pragma once
#include <concepts>
#include <limits>
#include <cmath>

/// @file
/// @brief Small constexpr integer utilities used for dimensions and bit manipulations.
///
/**
 * @details
 * This header provides:
 *  - `pow2(n)` : compute 2^n at compile time via bit-shift (returns an unsigned integral).
 *  - `is_power_of_two(x)` : test whether an integer is a (positive) power of two.
 *
 * Both functions are constexpr and noexcept and intended for use in compile-time
 * dimension computations (matrix sizes, state vector lengths) and static assertions.
 */

namespace ConstexprMath
{
    /**
     * @brief Compute 2 raised to the power of `n` at compile time.
     *
     * @tparam UIntType  Unsigned integral type used for the exponent and result.
     * @param n          Exponent (non-negative).
     * @return 2^n as `UIntType`.
     *
     * @note The implementation uses a left bit-shift on `1` which is defined for
     *       unsigned integral types and is constexpr-friendly.
     *
     * Example:
     * @code
     * constexpr auto four = ConstexprMath::pow2<std::size_t>(2); // four == 4
     * @endcode
     */
    template <std::unsigned_integral UIntType>
    constexpr UIntType pow2(UIntType n) noexcept
    {
        // Left-shift 1 by n positions: 1 << n == 2^n for unsigned types.
        return UIntType{ 1 } << n;
    }

    /**
     * @brief Determine whether a value is an exact power of two.
     *
     * @tparam UIntType  Unsigned integral type for the argument.
     * @param x          Value to test.
     * @return true if x is a power of two (1, 2, 4, 8, ...); false otherwise.
     *
     * @note This uses the classic bit trick: x > 0 && (x & (x - 1)) == 0.
     *       The operation is constexpr and does not allocate memory.
     */
    template <std::unsigned_integral UIntType>
    constexpr bool is_power_of_two(UIntType x) noexcept
    {
        // Fast test: powers of two have exactly one bit set.
        return x > 0 && (x & (x - 1)) == 0;
    }

    /**
     * @brief Compute the square root of a floating-point number at compile time.
     *
     * @param x  The input value (must be non-negative).
     * @return   The square root of x, or NaN if x is negative.
     *
     * @note This implementation uses the Newton-Raphson method for computing
     *       the square root and is constexpr-friendly.
	 */
    template <std::floating_point FloatType>
    constexpr FloatType sqrt(FloatType x) {
        // Handle edge cases
        if (x < 0.0) return std::numeric_limits<FloatType>::quiet_NaN();
        if (x == 0.0 || x == std::numeric_limits<FloatType>::infinity()) return x;

        // Recursive lambda for Newton-Raphson
        auto sqrtRec = [](FloatType x, FloatType curr, FloatType prev, auto&& self) -> FloatType {
            return curr == prev ? curr
                : self(x, 0.5 * (curr + x / curr), curr, self);
        };

        return sqrtRec(x, x, 0.0, sqrtRec);
    }

}ï»¿#pragma once
#include <cstdint>

/// @file
/// @brief Constexpr-friendly trigonometric helpers used to build unitary gates.
///
/**
 * @details
 * This header provides small, constexpr-capable approximations for sine and cosine
 * together with a minimal range-reduction routine. The implementations are intended
 * for use in compile-time construction of gate matrices (for example QFT) where
 * full runtime math library calls may not be available or desirable.
 *
 * Notes:
 *  - Approximations use low-order Taylor-like polynomials (suitable for small
 *    input magnitudes after range reduction).
 *  - Range reduction maps inputs to the primary approximation interval so the
 *    polynomial approximations remain accurate.
 *  - All functions are free of dynamic allocation and are trivial to evaluate
 *    in constexpr contexts.
 */

namespace ConstexprMath
{
    /// @brief Mathematical constant Ï€ (double precision).
    static constexpr double Pi = 3.141592653589793;

    /**
     * @brief Evaluate a polynomial approximation to sin(x) around 0.
     *
     * @param x  Input angle (radians). Intended to be small (|x| â‰² Ï€/4) after range reduction.
     * @return   Approximate sin(x).
     *
     * @remarks
     * The polynomial is derived from the Taylor series:
     *   sin(x) â‰ˆ x - x^3/6 + x^5/120 - x^7/5040
     * which has good accuracy for small |x|. This routine expects the caller to
     * first reduce the argument into the polynomial's region of accuracy.
     */
    constexpr double sin_poly(double x) noexcept {
        // Precompute x^2 to reuse in higher powers.
        const double x2 = x * x;
        // Evaluate x * (1 - x^2/6 + x^4/120 - x^6/5040)
        return x * (1.0
            - x2 / 6.0
            + x2 * x2 / 120.0
            - x2 * x2 * x2 / 5040.0);
    }

    /**
     * @brief Evaluate a polynomial approximation to cos(x) around 0.
     *
     * @param x  Input angle (radians). Intended to be small (|x| â‰² Ï€/4) after range reduction.
     * @return   Approximate cos(x).
     *
     * @remarks
     * The polynomial is taken from the Taylor series:
     *   cos(x) â‰ˆ 1 - x^2/2 + x^4/24 - x^6/720
     * which is accurate for small |x|.
     */
    constexpr double cos_poly(double x) noexcept {
        const double x2 = x * x;
        return 1.0
            - x2 / 2.0
            + x2 * x2 / 24.0
            - x2 * x2 * x2 / 720.0;
    }

    /**
     * @brief Floor implementation usable in constexpr context.
     *
     * @param x  A double value.
     * @return   The largest integer not greater than x, returned as int.
     *
     * @remarks
     * This simple helper casts to int32_t and corrects for truncated values
     * when x is negative and not an integer. It is small and constexpr-friendly.
     */
    constexpr int floor_constexpr(double x) {
        const int32_t i = static_cast<int32_t>(x);
        // Casting truncates toward zero; adjust when x < i to get true floor.
        return (x < static_cast<double>(i)) ? (i - 1) : i;
    }

    /**
     * @brief Reduce an arbitrary angle to the small interval used by the polynomial approximations.
     *
     * @param x  Input angle in radians.
     * @return   Reduced angle xr such that xr = x - k*(Ï€/2) for some integer k.
     *
     * @details
     * Range reduction strategy:
     *  - Compute k = floor((x + Ï€/4) / (Ï€/2)).
     *  - Subtract k*(Ï€/2) from x to obtain xr.
     *
     * The chosen formula maps x into the interval [-Ï€/4, Ï€/4) which is suitable
     * for the low-order polynomial approximations used above.
     */
    constexpr double reduce(double x) noexcept {
        // Determine the quadrant-like shift count k using a constexpr floor.
        double k = floor_constexpr((x + Pi / 4) / (Pi / 2));
        // Subtract k * (Ï€/2) to obtain the reduced angle.
        double xr = x - k * (Pi / 2);
        return xr;
    }

    /**
     * @brief Constexpr sine approximation for arbitrary input using range reduction + polynomial.
     *
     * @param x  Input angle in radians.
     * @return   Approximate sin(x).
     *
     * @remarks
     * The pipeline is:
     *  1) Reduce x into the small interval with `reduce`.
     *  2) Evaluate `sin_poly` on the reduced angle.
     *
     * For higher accuracy across the full domain, a full quadrant-aware sign/permute
     * handling can be added; the current routine relies on the reduction producing
     * a small xr where the polynomial approximation is valid.
     */
    constexpr double sin_constexpr(double x) noexcept {
        double xr = reduce(x);
        // Use the small-angle polynomial on the reduced value.
        return sin_poly(xr);
    }

    /**
     * @brief Constexpr cosine approximation for arbitrary input using range reduction + polynomial.
     *
     * @param x  Input angle in radians.
     * @return   Approximate cos(x).
     *
     * @remarks
     * Same pipeline as sin_constexpr: range reduction followed by polynomial evaluation.
     */
    constexpr double cos_constexpr(double x) noexcept {
        double xr = reduce(x);
        return cos_poly(xr);
    }
}#pragma once
    #include "types.h"

/// @file
/// @brief Common single- and two-qubit gate matrices and helpers.
///
/**
 * @details
 * Provides common quantum gates as `constexpr` matrices:
 *  - Identity, H, X, Y, Z, T, S, SWAP
 * and the `identity_matrix<QBitCount>()` helper for arbitrary qubit counts.
 */

namespace Gates
{
    /// @brief Mathematical constants used for gate definitions
    constexpr double sqrt2 = 1.4142135623730950;
    constexpr double inv_sqrt2 = 1.0 / sqrt2;

    /**
     * @brief Produce an identity matrix for `QBitCount` qubits (2^QBitCount × 2^QBitCount).
     * @tparam QBitCount  Number of qubits.
     * @return A diagonal identity matrix with ones on the main diagonal.
     */
    template<dimension_t QBitCount>
    constexpr matrix_t<ConstexprMath::pow2(QBitCount), ConstexprMath::pow2(QBitCount)> identity_matrix() noexcept
    {
        constexpr dimension_t Dim = ConstexprMath::pow2(QBitCount);

        // Zero-initialize and set the diagonal entries to 1.0
        matrix_t<Dim, Dim> identity = {};
        for (dimension_t i = 0; i < Dim; ++i)
        {
            identity[i][i] = cplx_t::fromReal(1.0);
        }
        return identity;
    }

    // Single-qubit identity
    constexpr matrix_t<2, 2> I = identity_matrix<1U>();

    // Hadamard gate: H = (1/sqrt(2)) * [[1, 1], [1, -1]]
    constexpr matrix_t<2, 2> H = {{
        { cplx_t(1.0 / sqrt2, 0.0), cplx_t(1.0 / sqrt2, 0.0) },
        { cplx_t(1.0 / sqrt2, 0.0), cplx_t(-1.0 / sqrt2, 0.0) }
    }};

    // Pauli-X (NOT)
    constexpr matrix_t<2, 2> X = {{
        { cplx_t(0.0, 0.0), cplx_t(1.0, 0.0) },
        { cplx_t(1.0, 0.0), cplx_t(0.0, 0.0) }
    }};

    // Pauli-Y
    constexpr matrix_t<2, 2> Y = {{
        { cplx_t(0.0, 0.0), cplx_t(0.0, -1.0) },
        { cplx_t(0.0, 1.0), cplx_t(0.0, 0.0) }
    }};

    // Pauli-Z
    constexpr matrix_t<2, 2> Z = {{
        { cplx_t(1.0, 0.0), cplx_t(0.0, 0.0) },
        { cplx_t(0.0, 0.0), cplx_t(-1.0, 0.0) }
    }};

    // 2-qubit SWAP gate
    constexpr matrix_t<4, 4> SWAP = {{
        { cplx_t(1.0, 0.0), cplx_t(0.0, 0.0), cplx_t(0.0, 0.0), cplx_t(0.0, 0.0) },
        { cplx_t(0.0, 0.0), cplx_t(0.0, 0.0), cplx_t(1.0, 0.0), cplx_t(0.0, 0.0) },
        { cplx_t(0.0, 0.0), cplx_t(1.0, 0.0), cplx_t(0.0, 0.0), cplx_t(0.0, 0.0) },
        { cplx_t(0.0, 0.0), cplx_t(0.0, 0.0), cplx_t(0.0, 0.0), cplx_t(1.0, 0.0) }
    }};

	// CNOT gate (controlled-X)
    constexpr matrix_t<4, 4> CX = {{
        { cplx_t(1.0, 0.0), cplx_t(0.0, 0.0), cplx_t(0.0, 0.0), cplx_t(0.0, 0.0) },
        { cplx_t(0.0, 0.0), cplx_t(1.0, 0.0), cplx_t(0.0, 0.0), cplx_t(0.0, 0.0) },
        { cplx_t(0.0, 0.0), cplx_t(0.0, 0.0), cplx_t(0.0, 0.0), cplx_t(1.0, 0.0) },
        { cplx_t(0.0, 0.0), cplx_t(0.0, 0.0), cplx_t(1.0, 0.0), cplx_t(0.0, 0.0) }
	} };
	constexpr auto CNOT = CX;



} // namespace Gates    
ï»¿#pragma once
#include "gates.h"
#include "constexpr_trigon.h"


namespace Gates
{
    /**
     * @brief     Construct the inverse Quantum Fourier Transform (QFTâ€ ) dense matrix for QBitCount qubits.
     *
     * @tparam QBitCount  Number of qubits (matrix dimension = 2^QBitCount).
     * @return A unitary matrix implementing the inverse QFT:
     *         U[j,k] = (1/sqrt(N)) * exp(-2Ï€ i j k / N)
     *
     * @note This routine is constexpr-friendly and uses the project's constexpr trigonometric
     *       helpers for compile-time matrix construction.
     */
    template<dimension_t QBitCount>
    constexpr matrix_t<ConstexprMath::pow2(QBitCount), ConstexprMath::pow2(QBitCount)>
        make_IQFT_matrix() noexcept
    {
        constexpr dimension_t N = ConstexprMath::pow2(QBitCount);
        constexpr double inv_sqrt_N = 1.0 / ConstexprMath::sqrt(static_cast<double>(N));

        matrix_t<N, N> M{};

        for (dimension_t j = 0; j < N; ++j)
        {
            for (dimension_t k = 0; k < N; ++k)
            {
                // angle = 2Ï€ * j * k / N
                const double angle =
                    2.0 * ConstexprMath::Pi * static_cast<double>(j * k)
                    / static_cast<double>(N);

                // For inverse QFT use the negative exponent:
                // exp(-i * angle) = cos(angle) - i * sin(angle)
                const double re = ConstexprMath::cos_constexpr(angle);
                const double im = -ConstexprMath::sin_constexpr(angle);

                M[j][k] = cplx_t(
                    inv_sqrt_N * re,
                    inv_sqrt_N * im
                );
            }
        }

        return M;
    }
}#pragma once
#include "types.h"
#include "quantum_gate_helpers.h"

template<index_t QBitCount>
class QuantumGate;

/**
 * @brief     Represents an application of a quantum gate to a specific set of qubits.
 *
 * @tparam QBitCount  Number of qubits the gate matrix acts on (compile-time).
 *
 * This class is a lightweight, non-copyable, non-movable handle that stores
 * a compile-time sized unitary matrix for the gate and a fixed list of
 * target qubit indices. Calling the object with a global state vector
 * applies the gate to the specified qubits and returns the transformed
 * global state vector (functional style).
 */
template<dimension_t QBitCount>
class QuantumGateOp
{
	/**
	 * @brief  The unitary matrix that defines the gate.
	 *
	 * Size: 2^QBitCount Ã— 2^QBitCount. Stored as a compile-time sized matrix type.
	 */
	const matrix_t<ConstexprMath::pow2(QBitCount), ConstexprMath::pow2(QBitCount)> gateMatrix;

	/**
	 * @brief  Fixed-size list of qubit indices affected by this gate.
	 *
	 * The order of indices in this list determines the mapping between the
	 * local basis bits ([0 .. 2^QBitCount)) and the global qubit positions.
	 */
	const qbit_list_t<QBitCount> affectedBits;

	// Delete copy constructor and copy assignment
	QuantumGateOp(const QuantumGateOp&) = delete;
	QuantumGateOp& operator=(const QuantumGateOp&) = delete;

	// Delete move constructor and move assignment
	QuantumGateOp(QuantumGateOp&&) = delete;
	QuantumGateOp& operator=(QuantumGateOp&&) = delete;

	/**
	 * @brief     Construct an operation from a gate matrix and affected qubits.
	 * @param U   The unitary gate matrix (must be square and unitary).
	 * @param affectedBits  The list of target qubit indices.
	 *
	 * Both `U` and `affectedBits` are stored by value (immutable after construction).
	 * Static assertions verify matrix shape and unitarity at compile-time where possible.
	 */
	constexpr QuantumGateOp(
		const matrix_t<ConstexprMath::pow2(QBitCount), ConstexprMath::pow2(QBitCount)>& U,
		const qbit_list_t<QBitCount>& affectedBits)
		: gateMatrix(U), affectedBits(affectedBits)
	{

	}

	// Allow the factory QuantumGate to access the private ctor
	friend class QuantumGate<QBitCount>;

public:
	/**
	 * @brief     Apply the stored gate to a global state vector and return the result.
	 *
	 * @tparam StateCount  Dimension of the global state vector (2^number_of_global_qubits).
	 * @param state        The input global state vector (passed by value â€” functional style).
	 * @return             A new global state vector with the gate applied to `affectedBits`.
	 *
	 * The algorithm partitions the global state into independent blocks of size 2^QBitCount.
	 * Each block corresponds to a fixed assignment of the unaffected qubits; the affected
	 * qubits span the local 2^QBitCount basis inside each block. For each block we:
	 *  1) gather the local amplitudes into `localIn`,
	 *  2) compute `localOut = gatematrix_t * localIn`,
	 *  3) write `localOut` back into the corresponding positions of the global state.
	 *
	 * Only indices where all targeted qubits are zero are treated as block "bases" to avoid
	 * redundant processing.
	 */
    template<dimension_t StateCount>
    constexpr state_vector_t<StateCount>
        operator()(state_vector_t<StateCount> state) const
    {
        // Total number of amplitudes in the global state vector
        constexpr dimension_t N = StateCount;

        // Number of qubits the gate operates on
        constexpr dimension_t k = QBitCount;

        // Local block size: 2^k amplitudes for the affected qubits
        constexpr dimension_t dim = ConstexprMath::pow2(k);

        // Work on a copy so the operation is functional (no side effects on input)
        state_vector_t<StateCount> result = state;

        // ------------------------------------------------------------------
        // 1) Build a bitmask identifying all qubits affected by this gate.
        //
        // The `targetMask` has bits set at positions of `affectedBits`. It
        // is used to detect indices where ALL affected qubits are zero
        // (these indices serve as base indices for the block iteration).
        // ------------------------------------------------------------------
        dimension_t targetMask = 0;
        for (dimension_t q : affectedBits)
        {
            // Set the bit corresponding to qubit `q`.
            targetMask |= (dimension_t(1) << q);
        }

        // ------------------------------------------------------------------
        // 2) Temporary local state vectors for one block
        //
        // `localIn` holds the amplitudes for the 2^k local basis states
        // (for the current configuration of the unaffected qubits).
        // `localOut` receives the gate-transformed amplitudes.
        // ------------------------------------------------------------------
        state_vector_t<dim> localIn{ cplx_t::zero() };
        state_vector_t<dim> localOut{ cplx_t::zero() };

        // ------------------------------------------------------------------
        // 3) Iterate over all global basis indices
        //
        // Only process indices `base` where none of the targeted qubit bits
        // are set. Each such `base` identifies one independent block of
        // size `dim` that will be transformed.
        // ------------------------------------------------------------------
        for (dimension_t base = 0; base < N; ++base)
        {
            // If any targeted qubit is 1 in `base` skip â€” we only treat the
            // canonical representative (where targeted qubits are all 0).
            if (base & targetMask)
                continue;

            // --------------------------------------------------------------
            // 4) Gather amplitudes for the current block into `localIn`.
            //
            // For each local index i âˆˆ [0, 2^k) interpret `i` as a bitmask
            // over the k affected qubits. Map those local bits into their
            // global positions (given by `affectedBits`) and read the
            // corresponding amplitude from `result`.
            // --------------------------------------------------------------
            for (dimension_t i = 0; i < dim; ++i)
            {
                // Start from the base index (all targeted qubits zero)
                dimension_t idx = base;

                // Map local bit b of `i` to global qubit position `affectedBits[b]`.
                for (dimension_t b = 0; b < k; ++b)
                {
                    if (i & (dimension_t(1) << b))
                    {
                        // Set the bit in the global index corresponding to the
                        // b-th local qubit being 1.
                        idx |= (dimension_t(1) << affectedBits[b]);
                    }
                }

                // Copy the amplitude into the local input vector.
                localIn[i] = result[idx];
            }

            // --------------------------------------------------------------
            // 5) Apply the quantum gate to the local block:
            //
            //    localOut = gatematrix_t Ã— localIn
            //
            // This uses the project's constexpr matrix-vector multiplication helper.
            // --------------------------------------------------------------
            localOut = apply_unitary(gateMatrix, localIn);

            // --------------------------------------------------------------
            // 6) Scatter the transformed amplitudes back into the global state.
            //
            // Reverse the mapping used in step 4 to place each `localOut[i]`
            // into the correct global index.
            // --------------------------------------------------------------
            for (dimension_t i = 0; i < dim; ++i)
            {
                dimension_t idx = base;

                // Map local index bits back to global qubit positions.
                for (dimension_t b = 0; b < k; ++b)
                {
                    if (i & (dimension_t(1) << b))
                    {
                        idx |= (dimension_t(1) << affectedBits[b]);
                    }
                }

                // Store the transformed amplitude.
                result[idx] = localOut[i];
            }
        }

        return result;
    }
};

/**
 * @brief     Factory for creating `QuantumGateOp` objects from a gate matrix.
 *
 * @tparam QBitCount  Number of qubits the gate matrix acts on.
 *
 * `QuantumGate` owns the gate matrix and exposes `toBits(...)` to bind the
 * matrix to a concrete set of qubit indices producing a `QuantumGateOp`.
 */
template<dimension_t QBitCount>
class QuantumGate
{
	/**
	 * @brief  The unitary matrix for this gate.
	 *
	 * The matrix is owned by the factory and used to construct `QuantumGateOp`
	 * instances. Kept immutable after construction.
	 */
	const matrix_t<ConstexprMath::pow2(QBitCount), ConstexprMath::pow2(QBitCount)> gateMatrix;

public:

	/**
	 * @brief     Construct a gate from its unitary matrix.
	 * @param U   The gate matrix (must be 2^QBitCount Ã— 2^QBitCount and unitary).
	 */
	constexpr explicit QuantumGate(
		const matrix_t<ConstexprMath::pow2(QBitCount), ConstexprMath::pow2(QBitCount)>& U)
		: gateMatrix(U) {
	}

	/**
	 * @brief     Bind this gate to a list of qubit indices and return an operation.
	 *
	 * @tparam QBits  Variadic list of indices convertible to `dimension_t`. The
	 *                number of provided indices must equal `QBitCount`.
	 * @param qbits   The qubit indices to which the gate will be applied.
	 * @return         A `QuantumGateOp<QBitCount>` object ready to apply the gate.
	 *
	 * Example:
	 *   auto h2 = QuantumGate<1>(HADAMARD).toBits(1);
	 */
	template<std::convertible_to<dimension_t>... QBits>
	constexpr QuantumGateOp<QBitCount> toBits(QBits... qbits) const
	{
		static_assert(sizeof...(qbits) == QBitCount);
        static_assert(is_valid_square_matrix(gateMatrix), "The provided matrix is not a valid square matrix.");
        //static_assert(is_unitary(gateMatrix), "The provided matrix is not unitary.");
		return QuantumGateOp<QBitCount>(gateMatrix, qbit_list_t<QBitCount>{ static_cast<dimension_t>(qbits)... });
	}
};
#pragma once
#include "types.h"


/// @file
/// @brief Helpers for applying gate matrices and validating matrix properties.
///
/**
 * @details
 * This header provides:
 *  - `apply_unitary` : constexpr matrix-vector multiplication (used to apply a local gate).
 *  - `is_valid_square_matrix` : compile-time check for square matrices with power-of-two size.
 *  - `is_unitary` : constexpr runtime/checkable check that a matrix is unitary.
 */

template<dimension_t Dim>
constexpr state_vector_t<Dim>
apply_unitary(const matrix_t<Dim, Dim>& U,
    const state_vector_t<Dim>& v) noexcept
{
    // Result initialized to zero amplitudes
    state_vector_t<Dim> result{ cplx_t::zero() };

    // Standard matrix-vector product:
    // result[i] = sum_j U[i][j] * v[j]
    for (dimension_t i = 0; i < Dim; ++i)
    {
        // Accumulate the i-th output amplitude
        for (dimension_t j = 0; j < Dim; ++j)
        {
            // Multiply the matrix row by the vector and add
            result[i] += U[i][j] * v[j];
        }
    }

    return result;
}

/// @brief  Checks if a matrix type is a valid square matrix whose dimensions are powers of two.
/// @tparam MatrixType  The matrix type to check. It is expected to expose `size()` and `at<0>().size()`.
/// @return     True if the matrix is square and both dimensions are non-zero powers of two, false otherwise.
///
/// @note This is a compile-time check (consteval). It validates shape constraints only; it does not inspect
///       element values.
template<dimension_t Dim>
constexpr bool is_valid_square_matrix(const matrix_t<Dim, Dim>& mat) noexcept
{
    constexpr std::size_t rows = mat.size();

    // If there are no rows or rows is not a power of two the type is invalid
    if constexpr ((rows == 0) || (!ConstexprMath::is_power_of_two(rows)))
    {
        return false;
    }
    else
    {
        // Inspect columns via the first row's container size
        constexpr std::size_t cols = mat[0].size();

        // Columns must be non-zero and a power of two
        if constexpr ((cols == 0) || !ConstexprMath::is_power_of_two(cols))
        {
            return false;
        }

        // Valid square iff rows == cols
        return rows == cols;
    }
}

/// @brief  Checks whether a provided square complex matrix is unitary.
/// @tparam Dim     Dimension of the square matrix (2^k).
/// @param mat      The matrix to check.
/// @return         True if mat * mat^† equals the identity, false otherwise.
///
/// @details
/// This function computes the conjugate transpose (Hermitian adjoint) of `mat`,
/// multiplies `mat` by its conjugate transpose and verifies that the product is
/// equal to the identity matrix within exact arithmetic. Because this routine
/// uses exact double checks for equality of re/im components, it is intended
/// for constexpr / compile-time constructed matrices used as gates.
template<dimension_t Dim>
constexpr bool is_unitary(const matrix_t<Dim, Dim>& mat) noexcept
{
    // Compute the conjugate transpose (mat^†)
    matrix_t<Dim, Dim> conj_transpose{};
    for (dimension_t i = 0; i < Dim; ++i) {
        for (dimension_t j = 0; j < Dim; ++j) {
            // element (j,i) of the conjugate transpose = conjugate of (i,j)
			//conj_transpose[j][i] = cplx_t(mat[i][j].re, -mat[i][j].im);
        }
    }   

    // Compute product = mat * mat^†
    matrix_t<Dim, Dim> product{};
    for (dimension_t i = 0; i < Dim; ++i) {
        for (dimension_t j = 0; j < Dim; ++j) {
            cplx_t sum = cplx_t::zero();

            // Accumulate the dot product of row i of mat and column j of conj_transpose
            for (dimension_t k = 0; k < Dim; ++k) {
                //sum += mat[i][k] * conj_transpose[k][j];
            }

            product[i][j] = sum;
        }
    }

    // Verify that the product equals the identity matrix exactly
    for (dimension_t i = 0; i < Dim; ++i) {
        for (dimension_t j = 0; j < Dim; ++j) {
            if (i == j) {
                // Diagonal must be 1 + 0i
                if (product[i][j].re != 1.0 || product[i][j].im != 0.0) {
                    return false;
                }
            } else {
                // Off-diagonals must be 0 + 0i
                if (product[i][j].re != 0.0 || product[i][j].im != 0.0) {
                    return false;
                }
            }
        }
    }
    return true;
}
#pragma once
#include <array>
#include "constexpr_complex.h"
#include "constexpr_pow2.h"

/// @file
/// @brief Core type aliases used across the project: sizes, complex number type, vectors and matrices.
///
/// @details
/// - `dimension_t` and `index_t` are the unsigned integral types used for sizes and indices.
/// - `cplx_t` is the project's constexpr-capable complex type.
/// - `state_vector_t<N>` is a std::array of `cplx_t` with N elements representing amplitudes.
/// - `matrix_t<R,C>` is a 2D std::array representing a matrix of complex amplitudes.
/// - `qbit_list_t<QBitCount>` is a fixed-size array of qubit indices used to specify affected qubits.
using dimension_t = std::size_t;
using index_t = std::size_t;

using cplx_t = ConstexprMath::Complex<double>;

/// @brief State vector with compile-time fixed size (array of complex amplitudes).
template<dimension_t StateCount>
using state_vector_t = std::array<cplx_t, StateCount>;

/// @brief Matrix type with compile-time fixed rows/columns.
/// @tparam Rows  Number of rows.
/// @tparam Cols  Number of columns.
template<dimension_t Rows, dimension_t Cols>
using matrix_t = std::array<std::array<cplx_t, Cols>, Rows>;

/// @brief Fixed-size list of qubit indices.
/// @tparam QBitCount  Number of qubits in the list.
template<index_t QBitCount>
using qbit_list_t = std::array<dimension_t, QBitCount>;
