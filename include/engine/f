#pragma once
#include "types.h"


/// @file
/// @brief Helpers for applying gate matrices and validating matrix properties.
///
/**
 * @details
 * This header provides:
 *  - Type trait `is_gate_matrix` to identify gate matrix types.
 *  - `apply_unitary` : constexpr matrix-vector multiplication (used to apply a local gate).
 *  - `is_valid_square_matrix` : compile-time check for square matrices with power-of-two size.
 *  - `is_unitary` : constexpr runtime/checkable check that a matrix is unitary.
 */

/// @brief  Type trait to check if a type is a gate matrix (square array of complex numbers).
template<typename T>
struct is_gate_matrix : std::false_type {};

template<size_t N>
struct is_gate_matrix<std::array<std::array<cplx_t, N>, N>> : std::true_type {
    static constexpr size_t dim = N;
};

template<typename T>
inline constexpr bool is_gate_matrix_v = is_gate_matrix<T>::value;


/// @brief  Applies a unitary matrix to a state vector via matrix-vector multiplication.
template<dimension_t Dim>
constexpr state_vector_t<Dim>
apply_unitary(const matrix_t<Dim, Dim>& U,
    const state_vector_t<Dim>& v) noexcept
{
    // Result initialized to zero amplitudes
    state_vector_t<Dim> result{ cplx_t::zero() };

    // Standard matrix-vector product:
    // result[i] = sum_j U[i][j] * v[j]
    for (dimension_t i = 0; i < Dim; ++i)
    {
        // Accumulate the i-th output amplitude
        for (dimension_t j = 0; j < Dim; ++j)
        {
            // Multiply the matrix row by the vector and add
            result[i] += U[i][j] * v[j];
        }
    }

    return result;
}

/// @brief  Checks if a matrix type is a valid square matrix whose dimensions are powers of two.
/// @tparam MatrixType  The matrix type to check. It is expected to expose `size()` and `at<0>().size()`.
/// @return     True if the matrix is square and both dimensions are non-zero powers of two, false otherwise.
///
/// @note This is a compile-time check (consteval). It validates shape constraints only; it does not inspect
///       element values.
template<dimension_t Dim>
constexpr bool is_valid_square_matrix(const matrix_t<Dim, Dim>& mat) noexcept
{
    constexpr std::size_t rows = mat.size();

    // If there are no rows or rows is not a power of two the type is invalid
    if constexpr ((rows == 0) || (!ConstexprMath::is_power_of_two(rows)))
    {
        return false;
    }
    else
    {
        // Inspect columns via the first row's container size
        constexpr std::size_t cols = mat[0].size();

        // Columns must be non-zero and a power of two
        if constexpr ((cols == 0) || !ConstexprMath::is_power_of_two(cols))
        {
            return false;
        }

        // Valid square iff rows == cols
        return rows == cols;
    }
}

/// @brief  Checks whether a provided square complex matrix is unitary.
/// @tparam Dim     Dimension of the square matrix (2^k).
/// @param mat      The matrix to check.
/// @return         True if mat * mat^† equals the identity, false otherwise.
///
/// @details
/// This function computes the conjugate transpose (Hermitian adjoint) of `mat`,
/// multiplies `mat` by its conjugate transpose and verifies that the product is
/// equal to the identity matrix within exact arithmetic. Because this routine
/// uses exact double checks for equality of re/im components, it is intended
/// for constexpr / compile-time constructed matrices used as gates.
template<auto M>
constexpr bool is_unitary()
{
	// Get the matrix dimension from the type trait
    constexpr size_t N = is_gate_matrix<std::remove_cvref_t<decltype(M)>>::dim;

	constexpr double epsilon = 1e-9;

	// Check unitarity: M * M^† == I
    for (size_t i = 0; i < N; i++)
        for (size_t j = 0; j < N; j++)
        {
            cplx_t sum{ 0,0 };
            for (size_t k = 0; k < N; k++)
                sum = sum + M[k][i].conj() * M[k][j];

			// Check against identity matrix
            if (i == j && (std::abs(sum.r - 1) > epsilon || std::abs(sum.i) > epsilon))
                return false;
            if (i != j && (std::abs(sum.r) > epsilon || std::abs(sum.i) > epsilon))
                return false;
        }
    return true;
}
